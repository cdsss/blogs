参考博客：https://blog.csdn.net/qq_33266987/article/details/51965221
（有些许改动）
一、预备知识：程序内存的分配
一个由C编译的程序占用的内存分为以下几个部分
1. 栈区（stack）：由编译器自动分配释放，存放函数的参数值，局部变量的值等。它的内存分配是连续分配的。
2. 堆区（heap）：由程序员分配释放。分配方式类似于链表，在内存中分布不连续。
3. 全局区（static）：全局变量和静态变量的存储是放在一起的，分为初始化和未初始化两部分（具体待根据ics补充）
4. 文字常量区：常量字符串等。
5. 程序代码区：存放函数体的二进制代码
备注：与ics课程区别在于栈堆的区分，注意其他几个区与课程本身的对应。

二、例子程序：
int a = 0; //全局初始化区
char *p1; //全局未初始化区
void main(){
    int b; //栈
    char s[] = "abc"; //栈
    char *p3 = "12345"; //p3在栈上，"12345/0"在常量区
    static int c = 0; //全局初始化区
    p1 = (char *)malloc(10);
    p2 = (char * malloc(20);
    // 分配得来的10和20字节的区域就在堆区
}

三、栈和堆的理论知识
3.1 申请方式
stack:
由系统自动分配。
heap:
需要程序员自己申请，并指明大小，在c中使用malloc函数，在c++中使用new
3.2 申请后系统的响应
栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。
堆：操作系统有一个记录空闲地址的链表，当系统收到程序的申请时会遍历该链表，寻找第一个空间大于所申请空间的堆结点
3.3 申请大小的限制
栈：在Windows下，栈是向低位扩展的数据结构，是一块连续的内存区域。在windows下，栈的大小是一个编译时就确定的常数。
    如果申请的空间超过栈的剩余空间时，将提示overflow
堆：堆是向高地址扩展的数据结构，是不连续的内存区域。堆的大小受限于计算机系统中有效的虚拟内存。
3.4 申请效率的比较：
栈：由系统自动分配，速度较快。但程序员无法控制。
堆：速度较慢
3.5 栈和堆的存储内容：
栈：在函数调用时，第一个进栈的是函数调用语句的下一条可执行语句的地址，然后是函数的各个参数（由右至左），然后是局部变量
堆：一般是在堆的头部用一个字节存放堆的大小。堆中内容由程序员安排。
